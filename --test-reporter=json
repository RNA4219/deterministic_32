import fs from 'node:fs';
import path from 'node:path';
import { spawn } from 'node:child_process';
import { pathToFileURL } from 'node:url';

const DESTINATION_PREFIX = '--test-reporter-destination=';
const DESTINATION_FLAG = '--test-reporter-destination';
const DEFAULT_DESTINATION = 'logs/test.jsonl';
const DEFAULT_TARGETS = ['dist/tests', 'dist/frontend/tests'];

const mapTargetArgument = (argument) => {
  if (!argument.endsWith('.ts')) {
    return argument;
  }

  const withoutExtension = argument.slice(0, -3);
  return path.join('dist', `${withoutExtension}.js`);
};

const parseCliArguments = () => {
  const passthroughArgs = [];
  const targetArgs = [];
  let reporterDestination;

  const argv = process.argv.slice(2);
  for (let index = 0; index < argv.length; index += 1) {
    const argument = argv[index];
    if (!argument) {
      continue;
    }

    if (argument === DESTINATION_FLAG) {
      const candidate = argv[index + 1];
      if (typeof candidate === 'string' && candidate.length > 0) {
        reporterDestination = candidate;
        index += 1;
      }
      continue;
    }

    if (argument.startsWith(DESTINATION_PREFIX)) {
      const suffix = argument.slice(DESTINATION_PREFIX.length);
      if (suffix.length > 0) {
        reporterDestination = suffix;
      }
      continue;
    }

    if (argument.startsWith('--')) {
      passthroughArgs.push(argument);
      continue;
    }

    if (fs.existsSync(argument)) {
      targetArgs.push(mapTargetArgument(argument));
      continue;
    }

    passthroughArgs.push(argument);
  }

  return { passthroughArgs, targetArgs, reporterDestination };
};

const resolveTargets = (explicitTargets) => {
  const targets = [];
  for (const candidate of DEFAULT_TARGETS) {
    if (fs.existsSync(candidate)) {
      targets.push(candidate);
    }
  }

  for (const target of explicitTargets) {
    if (!target) {
      continue;
    }
    let candidate = target;
    if (candidate.endsWith('.ts')) {
      const tsExtensionLength = path.extname(candidate).length;
      const withoutExtension = tsExtensionLength > 0
        ? candidate.slice(0, -tsExtensionLength)
        : candidate;
      candidate = `${path.join('dist', withoutExtension)}.js`;
    }
    if (!fs.existsSync(candidate)) {
      continue;
    }
    if (!targets.includes(candidate)) {
      targets.push(candidate);
    }
  }

  if (targets.length === 0) {
    targets.push(DEFAULT_TARGETS[0]);
  }

  return targets;
};

const resolveDestination = (explicitDestination) => {
  if (explicitDestination) {
    return explicitDestination;
  }
  for (const entry of fs.readdirSync('.', { withFileTypes: true })) {
    if (!entry.name.startsWith(DESTINATION_PREFIX)) {
      continue;
    }
    let suffix = entry.name.slice(DESTINATION_PREFIX.length);
    let current = entry.isDirectory() ? entry.name : null;
    while (current) {
      const contents = fs.readdirSync(current, { withFileTypes: true });
      const next = contents.find((item) => item.isDirectory());
      if (!next) {
        break;
      }
      suffix = path.join(suffix, next.name);
      current = path.join(current, next.name);
    }
    return suffix || DEFAULT_DESTINATION;
  }
  return DEFAULT_DESTINATION;
};

const { passthroughArgs, targetArgs, reporterDestination } = parseCliArguments();
const destination = resolveDestination(reporterDestination);
fs.mkdirSync(path.dirname(destination), { recursive: true });

const targets = resolveTargets(targetArgs);
const reporterSpecifier = pathToFileURL(path.resolve('reporters/json/index.js')).href;
const args = [
  '--test',
  `--test-reporter=${reporterSpecifier}`,
  `--test-reporter-destination=${destination}`,
  ...targets,
  ...passthroughArgs
];

const childEnv = { ...process.env };
delete childEnv.NODE_TEST_CONTEXT;
const spawnOverride = globalThis.__CAT32_TEST_SPAWN__;
const spawnFunction = typeof spawnOverride === 'function' ? spawnOverride : spawn;
const child = spawnFunction(process.execPath, args, { stdio: 'inherit', env: childEnv });
for (const signal of ['SIGINT', 'SIGTERM', 'SIGQUIT']) {
  process.on(signal, () => {
    if (!child.killed) {
      child.kill(signal);
    }
  });
}

const exitResult = await new Promise((resolve) => {
  child.once('error', (error) => {
    console.error(error);
    resolve({ code: 1, signal: null });
  });
  child.once('exit', (code, signal) => {
    resolve({ code, signal });
  });
});

if (exitResult.signal) {
  process.kill(process.pid, exitResult.signal);
} else {
  process.exit(exitResult.code ?? 1);
}
