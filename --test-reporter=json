import fs from 'node:fs';
import path from 'node:path';
import { spawn } from 'node:child_process';
import { pathToFileURL } from 'node:url';

const DESTINATION_PREFIX = '--test-reporter-destination=';
const DEFAULT_DESTINATION = 'logs/test.jsonl';
const DEFAULT_TARGETS = ['dist/tests', 'dist/frontend/tests'];

const parseCliArguments = (argv) => {
  const entries = [];
  let expectValueForFlag = false;
  let passthroughRemainder = false;

  for (const argument of argv) {
    if (!argument) {
      continue;
    }

    if (expectValueForFlag) {
      entries.push({ value: argument, passthrough: true });
      expectValueForFlag = false;
      continue;
    }

    if (passthroughRemainder) {
      entries.push({ value: argument, passthrough: true });
      continue;
    }

    if (argument === '--') {
      entries.push({ value: argument, passthrough: true });
      passthroughRemainder = true;
      continue;
    }

    if (argument.startsWith('--')) {
      entries.push({ value: argument, passthrough: true });
      if (!argument.includes('=')) {
        expectValueForFlag = true;
      }
      continue;
    }

    entries.push({ value: argument, passthrough: false });
  }

  return entries;
};

const normalizeTarget = (target) => {
  if (!target.endsWith('.ts')) {
    return target;
  }

  const tsExtensionLength = path.extname(target).length;
  const withoutExtension = tsExtensionLength > 0
    ? target.slice(0, -tsExtensionLength)
    : target;
  return path.join('dist', `${withoutExtension}.js`);
};

const prepareRunnerOptions = (
  argv = process.argv,
  {
    existsSync = fs.existsSync,
    defaultTargets = DEFAULT_TARGETS,
  } = {},
) => {
  const passthroughArgs = [];
  const explicitTargets = [];
  const resolvedDefaults = [];
  const seenTargets = new Set();
  let destinationOverride = null;

  const addTarget = (candidate) => {
    if (!candidate) {
      return;
    }

    const normalized = normalizeTarget(candidate);

    if (seenTargets.has(normalized)) {
      return;
    }

    seenTargets.add(normalized);
    explicitTargets.push(normalized);
  };

  const parsedArguments = parseCliArguments(argv.slice(2));

  for (const { value: argument, passthrough } of parsedArguments) {
    
    if (argument.startsWith(DESTINATION_PREFIX)) {
      const candidateDestination = argument.slice(DESTINATION_PREFIX.length);
      destinationOverride = candidateDestination || null;
      continue;
    }

    if (passthrough) {
      passthroughArgs.push(argument);
      continue;
    }

    const normalized = normalizeTarget(argument);

    if (existsSync(argument)) {
      addTarget(normalized);
      continue;
    }

    if (normalized !== argument && existsSync(normalized)) {
      addTarget(normalized);
      continue;
    }

    passthroughArgs.push(argument);
  }

  for (const candidate of defaultTargets) {
    if (!candidate) {
      continue;
    }

    const normalized = normalizeTarget(candidate);

    if (!existsSync(normalized)) {
      continue;
    }

    if (seenTargets.has(normalized)) {
      continue;
    }

    seenTargets.add(normalized);
    resolvedDefaults.push(normalized);
  }

  const targets = explicitTargets.length > 0 ? explicitTargets : resolvedDefaults;

  if (targets.length === 0 && defaultTargets.length > 0) {
    const fallbackCandidate = normalizeTarget(defaultTargets[0]);
    if (fallbackCandidate && !seenTargets.has(fallbackCandidate)) {
      targets.push(fallbackCandidate);
      seenTargets.add(fallbackCandidate);
    }
  }

  return { passthroughArgs, targets, destinationOverride };
};

const resolveDestination = (override) => {
  if (override) {
    return override;
  }

  for (const entry of fs.readdirSync('.', { withFileTypes: true })) {
    if (!entry.name.startsWith(DESTINATION_PREFIX)) {
      continue;
    }
    let suffix = entry.name.slice(DESTINATION_PREFIX.length);
    let current = entry.isDirectory() ? entry.name : null;
    while (current) {
      const contents = fs.readdirSync(current, { withFileTypes: true });
      const next = contents.find((item) => item.isDirectory());
      if (!next) {
        break;
      }
      suffix = path.join(suffix, next.name);
      current = path.join(current, next.name);
    }
    return suffix || DEFAULT_DESTINATION;
  }
  return DEFAULT_DESTINATION;
};

export { prepareRunnerOptions };

const runJsonReporter = async () => {
  const { passthroughArgs, targets, destinationOverride } = prepareRunnerOptions();
  const destination = resolveDestination(destinationOverride);
  const resolvedDestination = path.resolve(destination);
  fs.mkdirSync(path.dirname(resolvedDestination), { recursive: true });

  const reporterSpecifier = pathToFileURL(path.resolve('reporters/json/index.js')).href;
  const args = [
    '--test',
    `--test-reporter=${reporterSpecifier}`,
    `--test-reporter-destination=${resolvedDestination}`,
    ...targets,
    ...passthroughArgs
  ];

  const childEnv = { ...process.env };
  delete childEnv.NODE_TEST_CONTEXT;
  const spawnOverride = globalThis.__CAT32_TEST_SPAWN__;
  const spawnFunction = typeof spawnOverride === 'function' ? spawnOverride : spawn;
  const child = spawnFunction(process.execPath, args, { stdio: 'inherit', env: childEnv });
  for (const signal of ['SIGINT', 'SIGTERM', 'SIGQUIT']) {
    process.on(signal, () => {
      if (!child.killed) {
        child.kill(signal);
      }
    });
  }

  const exitResult = await new Promise((resolve) => {
    child.once('error', (error) => {
      console.error(error);
      resolve({ code: 1, signal: null });
    });
    child.once('exit', (code, signal) => {
      resolve({ code, signal });
    });
  });

  if (exitResult.signal) {
    process.kill(process.pid, exitResult.signal);
  } else {
    process.exit(exitResult.code ?? 1);
  }
};

if (process.env.__CAT32_SKIP_JSON_REPORTER_RUN__ !== '1') {
  await runJsonReporter();
}
