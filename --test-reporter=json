import fs from 'node:fs';
import path from 'node:path';
import { spawn } from 'node:child_process';
import { fileURLToPath, pathToFileURL } from 'node:url';

const DESTINATION_PREFIX = '--test-reporter-destination=';
const DEFAULT_DESTINATION = 'logs/test.jsonl';
const DEFAULT_TARGETS = ['dist/tests', 'dist/frontend/tests'];
const OPTIONS_EXPECTING_VALUE = new Set([
  '--import',
  '--loader',
  '--require',
  '--test-ignore',
  '--test-name-pattern',
  '--test-reporter',
  '--test-reporter-destination',
]);

const scriptDirectory = path.dirname(fileURLToPath(import.meta.url));

const projectRoot = (() => {
  let current = scriptDirectory;

  while (true) {
    if (path.basename(current) === 'dist') {
      const parent = path.dirname(current);

      if (parent !== current) {
        return parent;
      }

      return current;
    }

    const parent = path.dirname(current);

    if (parent === current) {
      return scriptDirectory;
    }

    current = parent;
  }
})();

const mapTargetArgument = (
  target,
  { existsSync = fs.existsSync, mapDirectoriesToDist = false } = {},
) => {
  if (!target) {
    return target;
  }

  const absoluteFromCwd = path.isAbsolute(target)
    ? target
    : path.resolve(target);
  const absoluteFromProject = path.isAbsolute(target)
    ? target
    : path.resolve(projectRoot, target);

  const absolute = (() => {
    if (path.isAbsolute(target)) {
      return target;
    }

    const existsFromCwd = existsSync(absoluteFromCwd);
    const existsFromProject = existsSync(absoluteFromProject);
    const currentDirectory = process.cwd();
    const cwdContainsCandidate = absoluteFromCwd.startsWith(`${currentDirectory}${path.sep}`) ||
      absoluteFromCwd === currentDirectory;

    if (existsFromCwd && !existsFromProject) {
      return absoluteFromCwd;
    }

    if (existsFromProject && !existsFromCwd) {
      return absoluteFromProject;
    }

    if (existsFromCwd && existsFromProject) {
      return cwdContainsCandidate ? absoluteFromCwd : absoluteFromProject;
    }

    if (cwdContainsCandidate) {
      return absoluteFromCwd;
    }

    return absoluteFromProject;
  })();

  const relativePathFromProject = path.relative(projectRoot, absolute);
  const normalizedRelative = path.normalize(relativePathFromProject);
  const extension = path.extname(normalizedRelative);
  const upwardPrefix = `..${path.sep}`;

  if (
    normalizedRelative === '..' ||
    normalizedRelative.startsWith(upwardPrefix)
  ) {
    return target;
  }

  if (extension === '.ts') {
    const withoutExtension = extension.length > 0
      ? normalizedRelative.slice(0, -extension.length)
      : normalizedRelative;

    const normalizedSegments = withoutExtension
      .split(path.sep)
      .filter((segment) => segment && segment !== '.' && segment !== '..');
    const distPath = path.join('dist', ...normalizedSegments);

    return `${distPath}.js`;
  }

  const inDistAlready =
    normalizedRelative === 'dist' ||
    normalizedRelative.startsWith(`dist${path.sep}`);

  if (inDistAlready) {
    return target;
  }

  const distCandidate = path.join('dist', normalizedRelative);
  const distCandidateAbsolute = path.resolve(projectRoot, distCandidate);

  if (mapDirectoriesToDist && extension.length === 0) {
    return distCandidate;
  }

  if (existsSync(distCandidate) || existsSync(distCandidateAbsolute)) {
    return distCandidate;
  }

  return target;
};

const prepareRunnerOptions = (
  argv = process.argv,
  {
    existsSync = fs.existsSync,
    defaultTargets = DEFAULT_TARGETS,
  } = {},
) => {
  const passthroughArgs = [];
  const explicitTargets = [];
  const resolvedDefaults = [];
  const seenTargets = new Set();
  let destinationOverride = null;
  let pendingOption = null;

  const addResolvedTarget = (candidate, bucket) => {
    if (!candidate) {
      return;
    }

    if (seenTargets.has(candidate)) {
      return;
    }

    seenTargets.add(candidate);
    bucket.push(candidate);
  };

  const resolveTargetCandidate = (candidate) => {
    if (!candidate || typeof candidate !== 'string') {
      return null;
    }

    const candidateExists = (value) => {
      if (!value || typeof value !== 'string') {
        return false;
      }

      const queue = path.isAbsolute(value)
        ? [path.normalize(value)]
        : [
            path.normalize(value),
            path.normalize(path.resolve(value)),
            path.normalize(path.resolve(projectRoot, value)),
          ];
      const seen = new Set();

      for (const entry of queue) {
        if (!entry || seen.has(entry)) {
          continue;
        }

        seen.add(entry);

        if (existsSync(entry)) {
          return true;
        }
      }

      return false;
    };

    const normalized = mapTargetArgument(candidate, {
      existsSync,
      mapDirectoriesToDist: true,
    });

    const toAbsoluteFromProject = (value) => {
      if (!value) {
        return null;
      }

      return path.isAbsolute(value)
        ? value
        : path.resolve(projectRoot, value);
    };

    const toAbsoluteFromCwd = (value) => {
      if (!value) {
        return null;
      }

      return path.isAbsolute(value) ? value : path.resolve(value);
    };

    const candidatesToCheck = (values) =>
      values.filter((value) => typeof value === 'string');

    const existsInAnyLocation = (...values) =>
      candidatesToCheck(values).some((value) => existsSync(value));

    if (normalized && normalized !== candidate) {
      if (
        existsInAnyLocation(
          normalized,
          toAbsoluteFromProject(normalized),
          toAbsoluteFromCwd(normalized),
          candidate,
          toAbsoluteFromProject(candidate),
          toAbsoluteFromCwd(candidate),
        )
      ) {
        return normalized;
      }
    }

    if (
      existsInAnyLocation(
        candidate,
        toAbsoluteFromProject(candidate),
        toAbsoluteFromCwd(candidate),
      )
    ) {
      return candidate;
    }

    return null;
  };

  for (const argument of argv.slice(2)) {
    if (!argument) {
      continue;
    }

    if (pendingOption) {
      if (pendingOption === '--test-reporter-destination') {
        destinationOverride = argument || null;
      } else {
        passthroughArgs.push(argument);
      }
      pendingOption = null;
      continue;
    }

    if (argument.startsWith(DESTINATION_PREFIX)) {
      const candidateDestination = argument.slice(DESTINATION_PREFIX.length);
      destinationOverride = candidateDestination || null;
      continue;
    }

    if (argument.startsWith('--')) {
      const assignmentIndex = argument.indexOf('=');
      const optionName = assignmentIndex === -1
        ? argument
        : argument.slice(0, assignmentIndex);
      const isDestinationOption =
        optionName === '--test-reporter-destination';

      if (!isDestinationOption) {
        passthroughArgs.push(argument);
      }

      if (assignmentIndex === -1) {
        if (OPTIONS_EXPECTING_VALUE.has(optionName)) {
          pendingOption = optionName;
        }
      } else if (isDestinationOption) {
        const value = argument.slice(assignmentIndex + 1);
        destinationOverride = value || null;
      }
      continue;
    }

    const resolvedTarget = resolveTargetCandidate(argument);

    if (resolvedTarget) {
      addResolvedTarget(resolvedTarget, explicitTargets);
      continue;
    }

    passthroughArgs.push(argument);
  }

  for (const candidate of defaultTargets) {
    if (!candidate) {
      continue;
    }

    const resolvedTarget = resolveTargetCandidate(candidate);

    if (!resolvedTarget) {
      continue;
    }

    addResolvedTarget(resolvedTarget, resolvedDefaults);
  }

  const targets = explicitTargets.length > 0 ? explicitTargets : resolvedDefaults;

  if (targets.length === 0 && defaultTargets.length > 0) {
    const fallbackCandidate = resolveTargetCandidate(defaultTargets[0]);
    addResolvedTarget(fallbackCandidate, targets);
  }

  return { passthroughArgs, targets, destinationOverride };
};

const ensureAbsoluteDestination = (candidate) => {
  if (!candidate) {
    return path.resolve(projectRoot, DEFAULT_DESTINATION);
  }

  if (path.isAbsolute(candidate)) {
    return candidate;
  }

  return path.resolve(projectRoot, candidate);
};

const resolveDestination = (override) => {
  if (override) {
    return ensureAbsoluteDestination(override);
  }

  for (const entry of fs.readdirSync(projectRoot, { withFileTypes: true })) {
    if (!entry.name.startsWith(DESTINATION_PREFIX)) {
      continue;
    }

    const entrySuffix = entry.name.slice(DESTINATION_PREFIX.length);
    let suffix = entrySuffix;
    let current = entry.isDirectory()
      ? path.resolve(projectRoot, entry.name)
      : null;

    while (current) {
      const contents = fs.readdirSync(current, { withFileTypes: true });
      const next = contents.find((item) => item.isDirectory());

      if (!next) {
        break;
      }

      suffix = path.join(suffix, next.name);
      current = path.join(current, next.name);
    }

    return ensureAbsoluteDestination(suffix || DEFAULT_DESTINATION);
  }

  return ensureAbsoluteDestination(DEFAULT_DESTINATION);
};

export { prepareRunnerOptions, resolveDestination };

const runJsonReporter = async () => {
  const { passthroughArgs, targets, destinationOverride } = prepareRunnerOptions();
  const destination = resolveDestination(destinationOverride);
  fs.mkdirSync(path.dirname(destination), { recursive: true });

  const reporterSpecifier = pathToFileURL(
    path.resolve(projectRoot, 'reporters/json/index.js'),
  ).href;
  const args = [
    '--test',
    `--test-reporter=${reporterSpecifier}`,
    `--test-reporter-destination=${destination}`,
    ...targets,
    ...passthroughArgs
  ];

  const childEnv = { ...process.env };
  delete childEnv.NODE_TEST_CONTEXT;
  const spawnOverride = globalThis.__CAT32_TEST_SPAWN__;
  const spawnFunction = typeof spawnOverride === 'function' ? spawnOverride : spawn;
  const child = spawnFunction(process.execPath, args, {
    stdio: 'inherit',
    env: childEnv,
    cwd: projectRoot,
  });
  for (const signal of ['SIGINT', 'SIGTERM', 'SIGQUIT']) {
    process.on(signal, () => {
      if (!child.killed) {
        child.kill(signal);
      }
    });
  }

  const exitResult = await new Promise((resolve) => {
    child.once('error', (error) => {
      console.error(error);
      resolve({ code: 1, signal: null });
    });
    child.once('exit', (code, signal) => {
      resolve({ code, signal });
    });
  });

  if (exitResult.signal) {
    process.kill(process.pid, exitResult.signal);
  } else {
    process.exit(exitResult.code ?? 1);
  }
};

if (process.env.__CAT32_SKIP_JSON_REPORTER_RUN__ !== '1') {
  await runJsonReporter();
}
